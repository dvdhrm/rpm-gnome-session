diff -up gnome-session-2.28.0/gnome-session/gsm-manager.c.unresponsive-timeout gnome-session-2.28.0/gnome-session/gsm-manager.c
--- gnome-session-2.28.0/gnome-session/gsm-manager.c.unresponsive-timeout	2009-09-18 12:36:04.000000000 -0400
+++ gnome-session-2.28.0/gnome-session/gsm-manager.c	2009-10-14 10:49:34.724468379 -0400
@@ -122,6 +122,7 @@ struct GsmManagerPrivate
         GsmManagerLogoutType    logout_type;
 
         GtkWidget              *inhibit_dialog;
+        guint                   inhibit_timeout_id;
 
         /* List of clients which were disconnected due to disabled condition
          * and shouldn't be automatically restarted */
@@ -797,6 +798,24 @@ inhibitor_has_flag (gpointer      key,
 }
 
 static gboolean
+is_responsive_inhibitor (gpointer      key,
+                         GsmInhibitor *inhibitor,
+                         gpointer      data)
+{
+        guint flag;
+        guint flags;
+        const gchar *reason;
+
+        flag = GPOINTER_TO_UINT (data);
+
+        flags = gsm_inhibitor_peek_flags (inhibitor);
+        reason = gsm_inhibitor_peek_reason (inhibitor);
+
+        return (flags & flag) &&
+               g_strcmp0 (_("Not responding"), reason) != 0;
+}
+
+static gboolean
 gsm_manager_is_logout_inhibited (GsmManager *manager)
 {
         GsmInhibitor *inhibitor;
@@ -833,6 +852,24 @@ gsm_manager_is_idle_inhibited (GsmManage
 }
 
 static gboolean
+gsm_manager_has_responsive_inhibitor (GsmManager *manager)
+{
+        GsmInhibitor *inhibitor;
+
+        if (manager->priv->inhibitors == NULL) {
+                return FALSE;
+        }
+
+        inhibitor = (GsmInhibitor *)gsm_store_find (manager->priv->inhibitors,
+                                                    (GsmStoreFunc)is_responsive_inhibitor,
+                                                    GUINT_TO_POINTER (GSM_INHIBITOR_FLAG_LOGOUT));
+        if (inhibitor == NULL) {
+                return FALSE;
+        }
+        return TRUE;
+}
+
+static gboolean
 _client_cancel_end_session (const char *id,
                             GsmClient  *client,
                             GsmManager *manager)
@@ -1055,6 +1092,11 @@ inhibit_dialog_response (GsmInhibitDialo
 
         g_debug ("GsmManager: Inhibit dialog response: %d", response_id);
 
+        if (manager->priv->inhibit_timeout_id > 0) {
+                g_source_remove (manager->priv->inhibit_timeout_id);
+                manager->priv->inhibit_timeout_id = 0;
+        }
+
         /* must destroy dialog before cancelling since we'll
            remove JIT inhibitors and we don't want to trigger
            action. */
@@ -1085,6 +1127,20 @@ inhibit_dialog_response (GsmInhibitDialo
         }
 }
 
+static gboolean
+on_inhibit_dialog_timeout (gpointer data)
+{
+        GsmManager *manager = data;
+
+        manager->priv->inhibit_timeout_id = 0;
+
+        inhibit_dialog_response (GSM_INHIBIT_DIALOG (manager->priv->inhibit_dialog),
+                                 GTK_RESPONSE_ACCEPT,
+                                 manager);
+
+        return FALSE;
+}
+
 static void
 query_end_session_complete (GsmManager *manager)
 {
@@ -1143,8 +1199,11 @@ query_end_session_complete (GsmManager *
                           "response",
                           G_CALLBACK (inhibit_dialog_response),
                           manager);
+        if (! gsm_manager_has_responsive_inhibitor (manager)) {
+                manager->priv->inhibit_timeout_id =
+                        g_timeout_add_seconds (120, on_inhibit_dialog_timeout, manager);
+        }
         gtk_widget_show (manager->priv->inhibit_dialog);
-
 }
 
 static guint32
@@ -2459,6 +2518,11 @@ gsm_manager_finalize (GObject *object)
 
         g_return_if_fail (manager->priv != NULL);
 
+        if (manager->priv->inhibit_timeout_id > 0) {
+                g_source_remove (manager->priv->inhibit_timeout_id);
+                manager->priv->inhibit_timeout_id = 0;
+        }
+
         G_OBJECT_CLASS (gsm_manager_parent_class)->finalize (object);
 }
 
