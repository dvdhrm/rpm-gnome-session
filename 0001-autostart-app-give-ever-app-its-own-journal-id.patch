From 5449174a1618cc7637f8c3a96c0eeae679c55248 Mon Sep 17 00:00:00 2001
From: Ray Strode <rstrode@redhat.com>
Date: Thu, 5 Nov 2015 09:41:16 -0500
Subject: [PATCH] autostart-app: give ever app its own journal id

Right now all session output gets attributed to
gnome-session which isn't very useful.

This commit makes sure launched apps each get
their own journal identifier.

https://bugzilla.gnome.org/show_bug.cgi?id=757571
---
 gnome-session/gsm-autostart-app.c | 44 ++++++++++++++++++++++++++++++++++++++-
 1 file changed, 43 insertions(+), 1 deletion(-)

diff --git a/gnome-session/gsm-autostart-app.c b/gnome-session/gsm-autostart-app.c
index 75008fe..08a434b 100644
--- a/gnome-session/gsm-autostart-app.c
+++ b/gnome-session/gsm-autostart-app.c
@@ -5,60 +5,65 @@
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
  * published by the Free Software Foundation; either version 2 of the
  * License, or (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <config.h>
 
 #include <ctype.h>
 #include <string.h>
 #include <sys/wait.h>
 #include <errno.h>
 
 #include <glib.h>
 #include <gio/gio.h>
 #include <gio/gdesktopappinfo.h>
 
 #ifdef HAVE_GCONF
 #include <gconf/gconf-client.h>
 #endif
 
+#ifdef HAVE_SYSTEMD
+#include <systemd/sd-journal.h>
+#include <systemd/sd-daemon.h>
+#endif
+
 #include "gsm-autostart-app.h"
 #include "gsm-util.h"
 
 enum {
         AUTOSTART_LAUNCH_SPAWN = 0,
         AUTOSTART_LAUNCH_ACTIVATE
 };
 
 enum {
         GSM_CONDITION_NONE           = 0,
         GSM_CONDITION_IF_EXISTS      = 1,
         GSM_CONDITION_UNLESS_EXISTS  = 2,
 #ifdef HAVE_GCONF
         GSM_CONDITION_GNOME          = 3,
 #endif
         GSM_CONDITION_GSETTINGS      = 4,
         GSM_CONDITION_IF_SESSION     = 5,
         GSM_CONDITION_UNLESS_SESSION = 6,
         GSM_CONDITION_UNKNOWN        = 7
 };
 
 #define GSM_SESSION_CLIENT_DBUS_INTERFACE "org.gnome.SessionClient"
 
 struct _GsmAutostartAppPrivate {
         char                 *desktop_filename;
         char                 *desktop_id;
         char                 *startup_id;
 
         GDesktopAppInfo      *app_info;
         /* provides defined in session definition */
@@ -987,93 +992,130 @@ gsm_autostart_app_stop (GsmApp  *app,
         case AUTOSTART_LAUNCH_ACTIVATE:
                 ret = autostart_app_stop_activate (aapp, error);
                 break;
         default:
                 g_assert_not_reached ();
                 break;
         }
 
         return ret;
 }
 
 static void
 app_launched (GAppLaunchContext *ctx,
               GAppInfo    *appinfo,
               GVariant    *platform_data,
               gpointer     data)
 {
         GsmAutostartApp *app = data;
         gint pid;
         gchar *sn_id;
 
         pid = 0;
         sn_id = NULL;
 
         g_variant_lookup (platform_data, "pid", "i", &pid);
         g_variant_lookup (platform_data, "startup-notification-id", "s", &sn_id);
         app->priv->pid = pid;
         app->priv->startup_id = sn_id;
 }
 
+#ifdef HAVE_SYSTEMD
+static void
+on_child_setup (GsmAutostartApp *app)
+{
+        int standard_output, standard_error;
+
+        /* The FALSE means programs aren't expected to prefix each
+         * line with <n> prefix to specify priority.
+         */
+        standard_output = sd_journal_stream_fd (app->priv->desktop_id,
+                                                LOG_INFO,
+                                                FALSE);
+        standard_error = sd_journal_stream_fd (app->priv->desktop_id,
+                                               LOG_WARNING,
+                                               FALSE);
+
+        if (standard_output >= 0) {
+                dup2 (standard_output, STDOUT_FILENO);
+                close (standard_output);
+        }
+
+        if (standard_error >= 0) {
+                dup2 (standard_error, STDERR_FILENO);
+                close (standard_error);
+        }
+}
+#endif
+
 static gboolean
 autostart_app_start_spawn (GsmAutostartApp *app,
                            GError         **error)
 {
         gboolean         success;
         GError          *local_error;
         const char      *startup_id;
         GAppLaunchContext *ctx;
+        GSpawnChildSetupFunc child_setup_func = NULL;
+        gpointer             child_setup_data = NULL;
         guint handler;
 
         startup_id = gsm_app_peek_startup_id (GSM_APP (app));
         g_assert (startup_id != NULL);
 
         g_debug ("GsmAutostartApp: starting %s: command=%s startup-id=%s", app->priv->desktop_id, g_app_info_get_commandline (G_APP_INFO (app->priv->app_info)), startup_id);
 
         g_free (app->priv->startup_id);
         local_error = NULL;
         ctx = g_app_launch_context_new ();
 
         if (g_getenv ("DISPLAY") != NULL) {
                 g_app_launch_context_setenv (ctx, "DISPLAY", g_getenv ("DISPLAY"));
         }
 
         if (startup_id != NULL) {
                 g_app_launch_context_setenv (ctx, "DESKTOP_AUTOSTART_ID", startup_id);
         }
 
+#ifdef HAVE_SYSTEMD
+        if (sd_booted () > 0) {
+                child_setup_func = (GSpawnChildSetupFunc) on_child_setup;
+                child_setup_data = app;
+        }
+#endif
+
         handler = g_signal_connect (ctx, "launched", G_CALLBACK (app_launched), app);
         success = g_desktop_app_info_launch_uris_as_manager (app->priv->app_info,
                                                              NULL,
                                                              ctx,
                                                              G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_SEARCH_PATH,
-                                                             NULL, NULL,
+                                                             child_setup_func, child_setup_data,
                                                              NULL, NULL,
                                                              &local_error);
         g_signal_handler_disconnect (ctx, handler);
 
         if (success) {
                 g_debug ("GsmAutostartApp: started pid:%d", app->priv->pid);
                 app->priv->child_watch_id = g_child_watch_add (app->priv->pid,
                                                                (GChildWatchFunc)app_exited,
                                                                app);
         } else {
                 g_set_error (error,
                              GSM_APP_ERROR,
                              GSM_APP_ERROR_START,
                              "Unable to start application: %s", local_error->message);
                 g_error_free (local_error);
         }
 
         return success;
 }
 
 static void
 start_notify (GObject      *source,
               GAsyncResult *result,
               gpointer      user_data)
 {
         GError          *error;
         GsmAutostartApp *app;
 
         app  = user_data;
         error = NULL;
-- 
2.5.0

